### Установка Плагина Gin для GoLand:

Перейти во "View" -> "Tool Windows" -> "Terminal".
В терминале выполнить команду для установки Gin:

```shell
go get -u github.com/gin-gonic/gin
``` 

### Включение отслеживания зависимостей:

Создать файл go.mod, если не создан. Выполните команду:

```shell
go mod init example/hello
```

Текстовый редактор создаст файл go.mod, отслеживающий зависимости.

### handlers:

обработчики (handlers) в папке handlers для обработки входящих запросов,
такие как создание заказа и получение всех заказов.

### models:

модель для заказа

### routes:

определением маршрутов, указывающих, какие обработчики вызывать для разных URL-ов.

Библиотека для миграций - gorm

### API-точек

Создать API, предоставляющее доступ к магазину, который продает виниловые записи старых джазовых альбомов.
Поэтому нужно будет предоставить конечные точки, через которые клиент сможет получать и добавлять альбомы для
пользователей.

Разработку API обычно начинают с проектирования конечных точек.
Пользователи нашего API будут лучше, если конечные точки будут легкими для понимания.

В этой инструкции создадим следующие конечные точки:

/albums
GET – Получить список всех альбомов в формате JSON.

POST – Создать новый альбом на основе данных запроса в формате JSON.

/albums/:id
GET – Получить альбом по его идентификатору, возвращая данные об альбоме в формате JSON.

Структуры данных для обработки информации.

Создание данных

Чтобы сделать учебное руководство проще, вы будете хранить данные в памяти.
В более типичном случае API взаимодействовало бы с базой данных.

Написание кода

Создать файл с именем main.go в директории web-service. В этом файле написать свой код на Go.

В файле main.go, в самом верху файла, вставить следующее объявление пакета.

```shell
package main
```

Самостоятельная программа (в отличие от библиотеки) всегда находится в пакете **main**.

Под объявлением пакета вставить следующее объявление структуры для альбома.
Будем использовать ее для хранения данных об альбомах в памяти.

Структурные теги, такие как json:"artist", указывают, каким должно быть имя поля, когда содержимое структуры
сериализуется в JSON.
Без них JSON использовал бы имена полей структуры с их начальной заглавной буквы - стиль, не так часто встречающийся в
JSON.

```shell
// album представляет данные об альбоме.
type album struct {
ID     string  `json:"id"`
Title  string  `json:"title"`
Artist string  `json:"artist"`
Price  float64 `json:"price"`
}
```

Под объявление структуры, вставить в следующий срез структур альбомов, содержащих данные, которые будем использовать.

```shell
// albums - срез для занесения данных о записях альбомов.
var albums = []album{
{ID: "1", Title: "Blue Train", Artist: "John Coltrane", Price: 56.99},
{ID: "2", Title: "Jeru", Artist: "Gerry Mulligan", Price: 17.99},
{ID: "3", Title: "Sarah Vaughan and Clifford Brown", Artist: "Sarah Vaughan", Price: 39.99},
}
```

Затем напишем код для реализации первой конечной точки.

Написание обработчика для возврата всех записей

Когда клиент делает запрос GET /albums, необходимо вернуть все альбомы в формате JSON.

Для этого напишем следующее:

Логика подготовки ответа.
Код для сопоставления пути запроса с логикой.
Обратите внимание, что это обратное тому, как это будет выполняться во время выполнения:
сначала добавляем зависимости, а затем код, который от них зависит.

Написание кода

Под кодом структуры, который добавили в предыдущем разделе, вставить следующий код для получения списка альбомов.

Эта функция getAlbums создает JSON из среза структур альбомов и записывает его в ответ.

```shell
// getAlbums возвращает список всех альбомов в формате JSON.
func getAlbums(c *gin.Context) {
c.IndentedJSON(http.StatusOK, albums)
}
```

В этом коде:

Написали функцию getAlbums, которая принимает параметр gin.Context. Обратите внимание, что вы могли бы дать этой функции
любое имя - ни Gin,
ни Go не требуют определенного формата имени функции.
gin.Context - это самая важная часть Gin. Она содержит детали запроса, проверяет и сериализует JSON и многое другое.
(Несмотря на схожее имя, это отличается от встроенного пакета контекста Go.)

Вызвали Context.IndentedJSON, чтобы сериализовать структуру в JSON и добавить ее в ответ.
Первым аргументом функции является HTTP-код состояния, который вы хотите отправить клиенту.
Здесь вы передаете константу StatusOK из пакета net/http для указания 200 OK.
Обратите внимание, что вы можете заменить Context.IndentedJSON вызовом Context.JSON для отправки более компактного JSON.
На практике отформатированная форма гораздо удобнее для отладки, и размер отличий обычно невелик.

В самом верху файла main.go, прямо под объявлением среза альбомов, вставьте следующий код, чтобы назначить функцию
обработчика пути.

Это настраивает ассоциацию, в которой getAlbums обрабатывает запросы к пути /albums.

```shell
func main() {
router := gin.Default()
router.GET("/albums", getAlbums)

    router.Run("localhost:8080")
}
```

В этом коде вы:

Инициализировали маршрутизатор Gin с помощью Default.
Использовали функцию GET, чтобы ассоциировать метод HTTP GET и путь /albums с функцией обработчика.
Обратите внимание, что вы передаете имя функции getAlbums.
Это отличается от передачи результата функции, что вы сделали бы, передавая getAlbums() (обратите внимание на скобки).
Использовали функцию Run, чтобы присоединить маршрутизатор к http.Server и запустить сервер.
В самом верху файла main.go, прямо под объявлением пакета, импортируйте пакеты, необходимые для поддержки кода, который
вы только что написали.

Первые строки кода должны выглядеть так:

    package main

    import (
    "net/http"
    
        "github.com/gin-gonic/gin"
    )

Сохранить main.go.

Запуск кода

Начнем отслеживать модуль Gin в качестве зависимости.
В командной строке используйте ```go get```, чтобы добавить модуль **github.com/gin-gonic/gin** в качестве зависимости
для вашего
модуля. Используйте аргумент точки для указания "получения зависимостей для кода в текущем каталоге".

```shell
$ go get .
```

Go разрешил и загрузил эту зависимость для удовлетворения объявления импорта, которое вы добавили на предыдущем шаге.

Из командной строки в каталоге, содержащем **main.go**, запустите код.

```shell
$ go run .
```

После того как код начнет выполняться, у вас будет работающий HTTP-сервер, к которому можно отправлять запросы.

Из нового окна командной строки используйте **curl** или **Postman**, чтобы сделать запрос к вашему работающему
веб-сервису.

```shell
$ curl http://localhost:8080/albums
```

Команда должна отобразить данные, которые вы добавили в сервис.

    [
    {
    "id": "1",
    "title": "Blue Train",
    "artist": "John Coltrane",
    "price": 56.99
    },
    {
    "id": "2",
    "title": "Jeru",
    "artist": "Gerry Mulligan",
    "price": 17.99
    },
    {
    "id": "3",
    "title": "Sarah Vaughan and Clifford Brown",
    "artist": "Sarah Vaughan",
    "price": 39.99
    }
    ]

Вы запустили API! В следующем разделе вы создадите еще одну конечную точку с кодом для обработки запроса POST для
добавления элемента.

Написание обработчика для добавления нового элемента

Когда клиент делает POST-запрос по адресу /albums, вы хотите добавить альбом, описанный в теле запроса, к существующим
данным об альбомах.

Для этого вы напишете следующее:

Логика для добавления нового альбома к существующему списку.
Немного кода для направления POST-запроса к вашей логике.

Написание кода

Добавьте код для добавления данных об альбомах в список альбомов.

Где-то после строк импорта вставьте следующий код. (Конец файла - хорошее место для этого кода, но Go не налагает
порядок объявления функций.)

```shell
// postAlbums добавляет альбом из JSON, полученного в теле запроса.
func postAlbums(c *gin.Context) {
    var newAlbum album

    // Вызовите BindJSON, чтобы привязать полученный JSON к
    // newAlbum.
    if err := c.BindJSON(&newAlbum); err != nil {
        return
    }

    // Добавьте новый альбом в срез.
    albums = append(albums, newAlbum)
    c.IndentedJSON(http.StatusCreated, newAlbum)
}
```

В этом коде вы:

Используете Context.BindJSON, чтобы привязать тело запроса к newAlbum.
Добавляете структуру альбома, инициализированную из JSON, в срез альбомов.
Добавляете статус кода 201 в ответ, вместе с JSON, представляющим добавленный альбом.
Измените вашу функцию main так, чтобы она включала функцию router.POST, как показано ниже.

```shell
func main() {
router := gin.Default()
router.GET("/albums", getAlbums)
router.POST("/albums", postAlbums)

    router.Run("localhost:8080")
}
```

В этом коде вы:

Связываете метод POST с путем /albums с функцией postAlbums.
С помощью Gin вы можете ассоциировать обработчик с комбинацией метода HTTP и пути. Таким образом, вы можете отдельно
маршрутизировать запросы, отправленные по одному пути, в зависимости от используемого клиентом метода.

Запуск кода

Если сервер все еще работает из предыдущего раздела, остановите его.

Из командной строки в каталоге, содержащем main.go, запустите код.

```shell
$ go run .
```

Из другого окна командной строки используйте curl или Postman, чтобы отправить запрос к вашему работающему веб-сервису.

```shell
$ curl http://localhost:8080/albums \
--include \
--header "Content-Type: application/json" \
--request "POST" \
--data '{"id": "4","title": "The Modern Sound of Betty Carter","artist": "Betty Carter","price": 49.99}'
```

Команда должна отобразить заголовки и JSON для добавленного альбома.

    HTTP/1.1 201 Created
    Content-Type: application/json; charset=utf-8
    Date: Wed, 02 Jun 2021 00:34:12 GMT
    Content-Length: 116
    
    {
    "id": "4",
    "title": "The Modern Sound of Betty Carter",
    "artist": "Betty Carter",
    "price": 49.99
    }

Получение полного списка альбомов

Как и в предыдущем разделе, используйте curl для получения полного списка альбомов, чтобы убедиться, что новый альбом
был добавлен.

```shell
curl http://localhost:8080/albums \
--header "Content-Type: application/json" \
--request "GET"
```

Команда должна отобразить список альбомов.

    [
    {
    "id": "1",
    "title": "Blue Train",
    "artist": "John Coltrane",
    "price": 56.99
    },
    {
    "id": "2",
    "title": "Jeru",
    "artist": "Gerry Mulligan",
    "price": 17.99
    },
    {
    "id": "3",
    "title": "Sarah Vaughan and Clifford Brown",
    "artist": "Sarah Vaughan",
    "price": 39.99
    },
    {
    "id": "4",
    "title": "The Modern Sound of Betty Carter",
    "artist": "Betty Carter",
    "price": 49.99
    }
    ]

В следующем разделе вы добавите код для обработки GET-запроса для конкретного элемента.

Написание обработчика для возврата конкретного элемента

Когда клиент делает запрос GET по адресу /albums/[id], вы хотите вернуть альбом, чей идентификатор соответствует
параметру пути id.

Для этого вы сделаете следующее:

Добавьте логику для извлечения запрошенного альбома.
Сопоставьте путь с логикой.
Напишите код

Под функцией postAlbums, добавьте следующий код для получения конкретного альбома.

```shell
// getAlbumByID находит альбом, значение ID которого совпадает с id,
// переданным клиентом, затем возвращает этот альбом в ответе.
func getAlbumByID(c *gin.Context) {
id := c.Param("id")

    // Пройдитесь по списку альбомов, ища
    // альбом, значение ID которого совпадает с параметром.
    for _, a := range albums {
        if a.ID == id {
            c.IndentedJSON(http.StatusOK, a)
            return
        }
    }
    c.IndentedJSON(http.StatusNotFound, gin.H{"message": "album not found"})
}
```

В этом коде вы:

Используете Context.Param, чтобы получить параметр пути id из URL. Когда вы отображаете этот обработчик на путь, вы
включите заполнитель для параметра в пути.
Проходитесь по структурам альбомов в срезе, ища ту, чье значение поля ID совпадает со значением параметра id. Если он
найден, вы сериализуете эту структуру альбома в JSON и возвращаете ее в ответе с HTTP-кодом 200 OK.

Если альбом не найден, возвращается HTTP-ошибка 404 с кодом http.StatusNotFound.
Наконец, измените свою функцию main так, чтобы она включала новый вызов router.GET, где путь теперь /albums/:id, как
показано в следующем примере.

```shell
func main() {
router := gin.Default()
router.GET("/albums", getAlbums)
router.GET("/albums/:id", getAlbumByID)
router.POST("/albums", postAlbums)

    router.Run("localhost:8080")

}
```

В этом коде:

Связываете путь /albums/:id с функцией getAlbumByID. В Gin двоеточие перед элементом в пути указывает, что элемент
является параметром пути.
Запуск кода

Если сервер все еще работает из предыдущего раздела, остановите его.

Из командной строки в каталоге, содержащем main.go, запустите код, чтобы запустить сервер.

```shell
$ go run .
```

Из другого окна командной строки используйте curl, чтобы сделать запрос к вашему работающему веб-сервису.

```shell
$ curl http://localhost:8080/albums/2
```

Команда должна отобразить JSON для альбома с использованием указанного вами ID. Если альбом не найден, вы получите JSON
с сообщением об ошибке.

    {
    "id": "2",
    "title": "Jeru",
    "artist": "Gerry Mulligan",
    "price": 17.99
    }

Для добавления миграций и использования базы данных PostgreSQL в вашем проекте Go с использованием Gin, 
вы можете использовать стороннюю библиотеку для миграций, такую как "golang-migrate/migrate", 
и библиотеку для работы с PostgreSQL, например, "github.com/jinzhu/gorm".

Вот пошаговый пример того, как вы можете это сделать:

Шаг 1: Установка библиотек
Установите необходимые библиотеки с помощью команды go get:

    go get -u github.com/gin-gonic/gin
    go get -u github.com/jinzhu/gorm
    go get -u github.com/jinzhu/gorm/dialects/postgres
    go get -u github.com/jinzhu/gormigrate
    go get -u github.com/golang-migrate/migrate/v4
    go get -u github.com/golang-migrate/migrate/v4/database/postgres
    
    ?go get -u gorm.io/gorm
    ?go get gorm.io/driver/postgres



    go get -u github.com/golang-migrate/migrate/v4/cmd/migrate

Создание миграции:
```shell
migrate create -ext sql -dir migrations -seq create_albums_table
```

    -- file: migrations/xxxxxxxxxxxx_create_albums_table.up.sql
    CREATE TABLE albums (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255),
    artist VARCHAR(255),
    price FLOAT
    );


Применение: 

```shell
migrate -database "postgres://postgres:12345@localhost:5432/postgres?sslmode=disable" -path migrations up
```


migrate create -ext sql -dir migrations -seq create_albums_table

go get -u github.com/jackc/pgx/v4


go list -m all > requirements.txt
go get -u